#!/usr/bin/perl -w

BEGIN {
    my $broot = $ENV{'BUILD_ROOT'};
    push @INC, "$broot/usr/lib/build/checks-data";
}

use strict;
use RPMQ;

### BEGIN CONFIG ##

my %permissions_d_whitelist = map { '/etc/permissions.d/'.$_ => 1 } qw/
lprng
lprng.paranoid
mail-server
mail-server.paranoid
postfix
postfix.paranoid
sendmail
sendmail.paranoid
squid
tetex
tetex.paranoid
/;

### END CONFIG ##

my $ret = 0;
my $needsecteam = 0;

my $root = $ENV{'BUILD_ROOT'} || die "must set \$BUILD_ROOT";

print "... checking for /etc/permissions* violations\n";

my %perms;

my %files = map { s/.*\///; s/\..*//; '/etc/permissions.d/'.$_ => 1 } glob($root.'/etc/permissions.d/*');
my @files = keys %files;
undef %files;

unshift @files, qw(/etc/permissions);

sub readpermfile($)
{
    my $f = shift;
    open(FH, '<', $f) or die "$f: $!";
    while(<FH>) {
	chomp;
	s/#.*//;
	next if(/^$/);

	my ($file, $owner, $mode, $garbage) = split(/\s+/);

	$owner =~ s/\./:/;

	$perms{$file}{'owner'} = $owner;
	$perms{$file}{'mode'} = oct($mode)&07777;
    }
    close(FH)
}

for my $i (@files)
{
    my $f = $root.$i;
    readpermfile($f) if (-e $f);
    $f .= '.secure';
    readpermfile($f) if(-e $f);
}

for my $rpm (glob($root."/usr/src/packages/RPMS/*/*")) {
    my (@errors, @warnings);
    my %r = RPMQ::rpmq_many($rpm, qw/FILENAMES FILEMODES FILEUSERNAME FILEGROUPNAME/);

    my $i = 0;
    for my $file (@{$r{'FILENAMES'}}) {

	my $mode = $r{'FILEMODES'}->[$i];
	my $owner = $r{'FILEUSERNAME'}->[$i].':'.$r{'FILEGROUPNAME'}->[$i];
	++$i;

#       S_IFSOCK   014   socket
#       S_IFLNK    012   symbolic link
#       S_IFREG    010   regular file
#       S_IFBLK    006   block device
#       S_IFDIR    004   directory
#       S_IFCHR    002   character device
#       S_IFIFO    001   FIFO
	my $type = ($mode>>12)&017;

	$mode &= 07777;
	if(exists($perms{$file}) || ($type == 04 && exists($perms{$file.'/'}))) {
	    if($type == 012) {
		push @warnings, "WARNING: permissions handling for symlink $file is useless\n";
		next;
	    }
	    my ($m, $o);
	    if($type == 04) {
		if(exists($perms{$file})) {
		    # legacy permissions files may still contain directories
		    # without slash appended.
		    push @warnings, "WARNING: $file is a directory, please append a slash to the filename\n";
		    $m = $perms{$file}{'mode'};
		    $o = $perms{$file}{'owner'};
		} else {
		    $m = $perms{$file.'/'}{'mode'};
		    $o = $perms{$file.'/'}{'owner'};
		}
	    } else {
		$m = $perms{$file}{'mode'};
		$o = $perms{$file}{'owner'};
	    }

	    if ($mode != $m) {
		push @errors, sprintf("ERROR: \%s has mode \%o but should be \%o\n", $file, $mode, $m);
	    }

	    if ($owner ne $o) {
		push @errors, "ERROR: $file belongs to $owner but should be $o\n";
	    }
	} elsif($type != 012) {
	    if(exists($perms{$file.'/'})) {
		push @errors, "ERROR: $file is a file but listed as directory\n";
	    }

	    if($mode&06000) {
		push @errors, sprintf "ERROR: \%s is packaged with setuid/setgid bits (\%o)\n", $file, $mode;
		$needsecteam = 1;
	    }

	    if($mode&02) {
		push @errors, sprintf "ERROR: \%s is packaged with world writable permissions (\%o)\n", $file, $mode;
		$needsecteam = 1;
	    }
	}

	if($file =~ /^\/etc\/permissions\.d\// && !exists($permissions_d_whitelist{$file})) {
	    push @errors, "ERROR: unauthorized permissions file: $file\n";
	    $needsecteam = 1;
	}
    }
    close(FH);

    if(@warnings || @errors) {
	$rpm =~ s/.*\/(.*?\/.*?)/$1/;
	print '  '.$rpm.":\n";
    }
    for my $w (@warnings) {
	print '    '.$w;
    }
    for my $e (@errors) {
	print '    '.$e;
    }
}

if($needsecteam) {
    print "\nPlease contact the SUSE Security Team <security-team\@suse.de>\n";
    $ret = 1;
}

exit $ret;

# vim: sw=4
